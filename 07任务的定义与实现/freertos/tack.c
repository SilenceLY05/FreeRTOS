#include "FreeRTOS.h"
#include "task.h"


/*
*************************************************************************
*                               任务控制块
*************************************************************************
*/

/* 当前正在运行的任务的任务控制块指针，默认初始化为NULL */
TCB_t * volatile pxCurrentTCB = NULL;

/* 任务就绪列表 */
List_t pxReadyTasksLists[configMAX_PRIORITIES];

static volatile UBaseType_t uxCurrentNumberOfTasks = (UBaseType_t) 0U;


static void  prvInitialiseNewTask(TaskFunction_t pxTaskCode,          /* 任务入口 */
																  const char* const pcName,           /* 任务名称，字符串形式 */
															  	const uint32_t ulStackDepth,        /* 任务栈大小，单位为字 */
																  void * const pvParameters,          /* 任务形参 */
															 	  TaskHandle_t* const puxStackBuffer,  /* 任务栈起始地址 */
																  TCB_t* const pxTaskBuffer );         /* 任务控制块指针 */



/* 静态任务创建函数 */
#if (configSUPPORT_STATIC_ALLOCATION == 1)


TaskHandle_t xTaskCreateStatic(TaskFunction_t pxTaskCode,          /* 任务入口 */
																 const char* const pcName,           /* 任务名称，字符串形式 */
																 const uint32_t ulStackDepth,        /* 任务栈大小，单位为字 */
																 void * const pvParameters,          /* 任务形参 */
																 StackType_t* const puxStackBuffer,  /* 任务栈起始地址 */
																 TCB_t* const pxTaskBuffer )         /* 任务控制块指针 */
{
	TCB_t *pxNewTCB;
	TaskHandle_t xReturn;           /* 定义一个任务句柄用于指向任务的TCB */
	
	if((pxTaskBuffer != NULL) && (puxStackBuffer != NULL))
	{
		pxNewTCB = (TCB_t*) pxTaskBuffer;
		pxNewTCB->pxStack = (StackType_t*)puxStackBuffer;
		
		/* 创建新的任务 */
		prvInitialiseNewTask(pxTaskCode, pcName,ulStackDepth,pvParameters,&xReturn,pxNewTCB);
	}
	else
	{
		xReturn = NULL;
	}
	
	/* 返回任务句柄，如果任务创建成功，此时xReturn应该指向任务控制块 */
	return xReturn;
}

#endif /* configSUPPORT_STATIC_ALLOCATION */



static void  prvInitialiseNewTask(TaskFunction_t pxTaskCode,          /* 任务入口 */
																  const char* const pcName,           /* 任务名称，字符串形式 */
															  	const uint32_t ulStackDepth,        /* 任务栈大小，单位为字 */
																  void * const pvParameters,          /* 任务形参 */
															 	  TaskHandle_t* const pxCreatedTask,  /* 任务句柄 */
																  TCB_t*  pxNewTCB )         /* 任务控制块指针 */
{
	StackType_t* pxTopOfStack;
	UBaseType_t x;
	
	/* 获取栈顶地址 */
	pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
	
	/* 向下做8字节对齐 */
	pxTopOfStack = (StackType_t*) (((uint32_t)pxTopOfStack)&(~((uint32_t)0x007)));
	
	/* 将任务的名字存储在TCB中 */
	for(x=(UBaseType_t)0;x<(UBaseType_t)configMAX_TASK_NAME_LEN;x++)
	{
		pxNewTCB->pcTackName[x] = pcName[x];
		
		if(pcName[x] == 0x00)
		{
			break;
		}
	}
	
	/* 任务名字的长度不能超过configMAX_TASK_NAME_LEN */
	pxNewTCB->pcTackName[configMAX_TASK_NAME_LEN - 1] = '\0';
	
	/* 初始化TCB中的xStateListItem节点 */
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
	
	/* 设置xStateListItem节点的拥有者 */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
	
	/* 初始化任务栈 */
	pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack,pxTaskCode,pvParameters);
	
	/* 让任务句柄指向任务控制块 */
	if((void*)pxCreatedTask != NULL)
	{
		*pxCreatedTask = (TaskHandle_t) pxNewTCB;
	}

}


/* 初始化任务相关的列表 */
void prvInitialiseTaskLists( void )
{
  UBaseType_t uxPriority;
    
    
  for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialist( &( pxReadyTasksLists[ uxPriority ] ) );
	}
}

extern TCB_t Task1TCB;
extern TCB_t Task2TCB;
void vTaskStartScheduler( void )
{
    /* 手动指定第一个运行的任务 */
    pxCurrentTCB = &Task1TCB;
    
    /* 启动调度器 */
    if( xPortStartScheduler() != pdFALSE )
    {
        /* 调度器启动成功，则不会返回，即不会来到这里 */
    }
}

void vTaskSwitchContext( void )
{    
    /* 两个任务轮流切换 */
    if( pxCurrentTCB == &Task1TCB )
    {
        pxCurrentTCB = &Task2TCB;
    }
    else
    {
        pxCurrentTCB = &Task1TCB;
    }
}
